# chapter1(오브젝트와 의존관계)

## 들어가며

- 스프링을 잘 사용하려면, 스프링 컨테이너를 다루는 방법과 설정정보를 작성하는 방법을 알아야 한다.
- 스프링이 제공하는 3가지 핵심 프로그래밍 모델
    1. **IoC/DI** : 프레임워크의 근간.
    2. **서비스 추상화** : 구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 둔다.
    3. **AOP** : 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델.
- 스프링 통해 얻게 되는 두 가지 중요한 가치
    1. **단순함** : **기존 EJB**라는 강한 권위 가졌던 표준 기술 비판하며 등장.
    스프링이 강력히 주장하는 것은 가장 단순한 객체지향적 개발 모델인 **POJO 프로그래밍**
    2. **유연성** : 다른 많은 프레임워크와 편리하게 접목되어 사용가능. a.k.a glue 프레임워크.

---

스프링은, 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누리도록 기본으로 돌아가는 것을 핵심 가치로 둔다.

그런 점에서 **오브젝트**는 스프링에서 관심을 가장 많이 두는 대상이다. ****생성, 관계, 사용, 소멸에 대한 생각을 하게 되면, 객체지향 설계 기초와 원칙을 비롯해서 디자인 패턴, 리팩토링 그리고 단위 테스트와 같은 오브젝트 설계와 구현에 관한 여러 응용 기술과 지식이 요구된다.

## 1.1 초난감 DAO

cf. 자바빈 : 디폴트 생성자, 프로퍼티 with getter/setter

- 예제 step0)
내용 : add, get에 대해서 "연결 - 준비 - 실행 - 자원해제" 중복 코드.

## 1.2 DAO의 분리

- 관심사의 분리(Separation of Concerns) : 한 가지 관심이 한 관심에 집중. 관심이 다른 것은 따로 떨어져 있게 하는 것.
- **step1)** Connection 만들기 추출
적용 방식 : refactoring ; 기능 영향 주지 않으면서 깔끔하게 구조만 변경, extract method ; 공통 기능 추출. 독립된 메서드 분리.
 내용 : getConnection() 메서드 분리해서, add와 get 메서드에서 공통으로 사용.
→ 관심 내용이 독립적으로 존재해서, 수정이 간단해짐.

- 요구사항의 추가 ; UserDao는 바이너리 파일만 제공해줄 때
**step2)** abstract class UserDao 만들고, 로직 흐름은 만들고, 추상 메서드는 서브 클래스 구현에 맡김.
// 템플릿 메소드 패턴, 팩토리 메소드 패턴
한 마디로 내용 : UserDao에 팩토리 메소드 패턴 적용해서, getConnection() 분리
→ 연결 기능과 사용자 정보 저장/조회 기능 '변화의 성격'에 따라 분리
    - 변화의 성격이 다르다 : 변화의 이유와 시기, 주기 등이 다름!
        - 상속을 사용해서 너무 밀접, UserDao가 상속하는 것이 있다면 불가.

## 1.3 DAO의 확장

step2에서, 추상 클래스를 만들고, 상속한 서브 클래스에서 변화가 필요한 부분을 바꿔쓰도록 한 이유는, 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적인 변경을 하게 하기 위함이었다. 그러나 상속이라는 단점많은 방식을 썼다.
→ 상하위 클래스를 만들었던 것에 대해, 독립적인 클래스를 만들어 보자!

**클래스 분리 1st 시도 step3)**
// 목표 : 상속에서 벗어나기

UserDAO → SimpleConnectionMaker

- 문제
    - 메서드 모두 수정해야함ㅗ
    - DB 커넥션 제공하는 클래스가 어떤 것인지 UserDao가 알고 있어야함.

**클래스 분리 2nd 시도 step4)**
// 핵심 : 인터페이스 사용
**-** UserDao → ConnectionMaker interface
- NConnectionMaker DConnectionMaker implements ConnectionMaker

- 문제 : UserDao 안에서 Connection 구현체 클래스 생성 호출 ; **관계 설정 별도 위임 필요**

```java
public UserDao() {
  this.connectionMaker = new DConnectionMaker();
}
// 이 자체가 찗지만, 충분히 독립적인 관심사다!
// → UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현체 사이 관계 설정!!
// 분리하지 않으면 UserDao는 결코 독립적 확장 불가.
```

**step5)**

이제는 UserDao의 클라이언트에게 런타임 오브젝트 관계를 갖는 구조로 만들어주는 책임을 넘겨보자.

- 오브젝트 사이 관계는 클래스 사이 관계와 다르다. 코드에 보이지 않던 관계가 오브젝트로 만들어진 후 성립되는 관계!
EX> UserDao → DConnectionMaker
- UserDao의 관심/책임도 아닌 것을, 클라이언트에게!

```java
public class UseerDaoTest {

  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    // UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트 만든다
    ConnectionMaker connectionMaker = new DConnectionMaker();
    // 1 UserDao 생성, 2 사용할 ConnectionMaker 타입의 오브젝트 제공; 오브젝트 사이 의존관계 설정
    UserDao dao = newe UserDao(connectionMaker);
  }
}
```

### 지금까지 본 원칙과 패턴

- OCP(개방 폐쇄 원칙) : 클래스나 모듈은 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 높은 응집도 : 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 할 수 있다.
ex> DB 연결방식 변경 검증한다면, ConnectionMaker 구현 클래스만 체크하면 된다.
- 낮은 결합도 : 높은 응집도보다 더 민감한 원칙. 느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만드는 것.
- 결합도 : 하나의 오브젝트가 변경이 일어날 때에 관게를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도
- 전략 패턴 : 자신의 기능의 맥락에서, 필요에 따라 구체적인 알고리즘 클래스(책임 분리가능 클래스)를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴. 클라이언트가 컨텍스트에 사용할 전략을 컨텍스트의 생성자를 통해 제공하는 게 일반적.

## 1.4 제어의 역전 (IoC)

이전까지 해온 것 잠시 돌아보면, UserDaoTest에서는 테스트를 넘어서, 관계 설정하는 역할도 갖고 있다!

두 개 오브젝트가 연결돼서 사용될 수 있도록 관계 설정하는 것도 분리해보자.

**팩토리** : 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할 담당.

```java
public class DaoFactory {
  public UserDao userDao() {
     ConnectionMaker connectionMaker = new DConnectionMaker();
     UserDao userDao = new UserDao(connectionMaker);
     return userDao;
  }
}

public class UseerDaoTest {

  public static void main(String[] args) throws ClassNotFoundException, SQLException {
  
    UserDao dao = new DaoFactory().userDao();
  }
}
```

→ 애플리케이션의 컴포넌트 역할을 하는 오브젝트와, ; Client, UserDao, ConnectionMaker

애플리케이션의 구조를 결정하는 오브젝트를 분리했다! ; DaoFactory

### 제어의 역전

프로그램의 제어 흐름 구조가 바뀌는 것!

오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.

모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.

- 디자인 패턴에서의 예시 - 템플릿 메서드 패턴
제어권을 상위 템플릿 메소드에 넘기고, 자신은 필요할 때 호출되어 사용된다.

- 라이브러리 vs 프레임워크 : 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어. 반면, 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다.

## 1.5 스프링의 IoC

스프링의 핵심을 담당하는 것 : 빈 팩토리 혹은 애플리케이션 컨텍스트
; 우리가 만든 DaoFactory가 하는 일을 좀 더 일반화한 것이다.

- 빈 : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트

### 애플리케이션 컨텍스트

- 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
- 별도의 정보를 참고해서 빈(오브젝트)의 생성, 관계설정 등의 제어 작업을 총괄한다.

## 스터디관련#1



### 추가로 알아보게 된 것

- 스프링의 모든 기술은 JavaEE에 기반
→ JavaEE?
- 기존 EJB ; 자바 EE 기술의 혼란 - 기존 문제는 구체적으로 무엇일까?
[https://okky.kr/article/415474](https://okky.kr/article/415474)
    - EBJ는 JavaEE의 핵심
        - 미들웨어에 필요한 공통 API를 제공하는 컨셉으로 만들어짐.
        - ↔ Servlet, JSP는 웹  GUI위해 필요.
        - 실용성보다는 API 모양새, 플랫폼 독립성이라는 자바 특성만 강조하여 설계해서 불편한 점 많음.
            - 미들웨어 종속을 극복하기 위해 만들었으나, 자바EE 서버 제품에 종속되어 버리는 아이러니한 상황 발생
            - 당시에는 '의미있는 기본값' 혹은 '설정보다는 관행' 같은 사상이 널리 쓰이기 이전 ; xml 지옥
    - 스프링
        - 풀스택 서버가 아닌 서블릿 컨테이너에서 구동
        - 스프링을 통해 비싼 자바EE 서버를 구매하지 않아도 **EJB보다 훨씬 간편한 방식**으로 EJB가 제공하던 선언적 트랜잭션 및 보안 처리, 분산 환경 지원 등 주요 기능을 모두 사용할 수 있게 되었음을 뜻하며, 무엇보다 이제는 더 이상 각 자바EE 서버 제품에 특화된 설정을 따로 공부하거나 서버 제품을 바꿀 때마다 포팅 작업이 필요없이 스프링만 이용하면 탐캣이든 레진(Resin)이든 기존의 풀스택 자바EE 서버이든 관계없이 **간단하게 배포**가 가능하다
- POJO 프로그래밍
Plain Old Java Object, 간단히 POJO는 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어
- 스프링 창립자의 철학?

### 만들어본 질문

- 오브젝트 팩토리 대비, 어플리케이션 컨텍스트 사용시의 장점은?

1 클라이언트는 구체적인 팩토릴 클래스를 알 필요가 없다
2 애플리케이션 컨텍스트는 통합 IoC서비스를 제공해준다.
3 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
- 낮은 결합도, 높은 응집도 설명 ; 우리 봤던 클래스 예시로 들어서!

[2020.11.09 (월) 1회 스터디 나눈 점 정리](review1.md)
